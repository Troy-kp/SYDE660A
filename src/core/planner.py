#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SYDE Course Planner
===================
A comprehensive course planning system for Systems Design Engineering graduate students.

Usage:
    python planner.py

"""

import json
import os
import re
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from collections import defaultdict
from pathlib import Path
import itertools
from .requirements_formatter import RequirementsFormatter

# --- Path Configuration ---
# Get the absolute path to the project's root directory
# This makes the script runnable from any location
try:
    # Assumes the script is in src/core/
    PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
except NameError:
    # Fallback for interactive environments
    PROJECT_ROOT = Path('.').resolve()

DATA_DIR = PROJECT_ROOT / "data"

# --- Data Classes ---
@dataclass
class Course:
    """Course data structure"""
    course_id: str
    subject_code: str
    catalog_number: str
    title: str
    description: str
    credit_weight: float
    requirements_description: Optional[str]
    term_code: str
    term_name: str
    academic_career: str
    
    @property
    def course_code(self) -> str:
        return f"{self.subject_code} {self.catalog_number}"

@dataclass
class CourseRequirement:
    """Course requirement structure"""
    type: str  # 'compulsory', 'compulsory_choice', 'elective', 'specified'
    courses: List[str]
    n_to_choose: int = 1
    description: str = ""

# REMOVED SemesterPlan dataclass as it's no longer generated by the backend

class PrerequisiteParser:
    """Parse course prerequisites from text descriptions"""
    
    def __init__(self):
        self.prereq_patterns = [
            r'[Pp]re[-]?req(?:uisite)?s?[:]\s*',
            r'[Pp]rerequisite?s?[:]\s*'
        ]
        self.antireq_patterns = [
            r'[Aa]nti[-]?req(?:uisite)?s?[:]\s*',
            r'[Aa]ntirequisite?s?[:]\s*'
        ]
        self.coreq_patterns = [
            r'[Cc]o[-]?req(?:uisite)?s?[:]\s*',
            r'[Cc]orequisite?s?[:]\s*'
        ]
    
    def parse_requirements(self, requirements_text: str) -> Dict[str, List[str]]:
        """Parse course requirements text into structured data"""
        if not requirements_text:
            return {'prereq': [], 'antireq': [], 'coreq': []}
        
        result = {
            'prereq': self._extract_courses(requirements_text, self.prereq_patterns),
            'antireq': self._extract_courses(requirements_text, self.antireq_patterns),
            'coreq': self._extract_courses(requirements_text, self.coreq_patterns)
        }
        
        # Handle mixed formats like "Prereq/coreq:"
        if 'prereq/coreq' in requirements_text.lower():
            courses = self._extract_mixed_requirements(requirements_text)
            result['prereq'].extend(courses)
            result['coreq'].extend(courses)
        
        return result
    
    def _extract_courses(self, text: str, patterns: List[str]) -> List[str]:
        """Extract course codes for specific requirement types"""
        courses = []
        for pattern in patterns:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            for match in matches:
                start = match.end()
                end = self._find_next_boundary(text, start)
                segment = text[start:end]
                
                # Extract course codes (e.g., SYDE 600, CS 240)
                course_codes = re.findall(r'\b([A-Z]{2,6})\s*(\d{3}[A-Z]?)\b', segment)
                courses.extend([f"{subj} {num}" for subj, num in course_codes])
        
        return list(set(courses))
    
    def _find_next_boundary(self, text: str, start: int) -> int:
        """Find the end of current requirement section"""
        # Look for next requirement keyword or sentence end
        boundaries = []
        for pattern_group in [self.prereq_patterns, self.antireq_patterns, self.coreq_patterns]:
            for pattern in pattern_group:
                match = re.search(pattern, text[start:], re.IGNORECASE)
                if match:
                    boundaries.append(start + match.start())
        
        # Also look for period or semicolon
        punctuation = re.search(r'[.;]', text[start:])
        if punctuation:
            boundaries.append(start + punctuation.start())
        
        return min(boundaries) if boundaries else len(text)
    
    def _extract_mixed_requirements(self, text: str) -> List[str]:
        """Extract courses from mixed requirement formats"""
        # Simple implementation for "Prereq/coreq: COURSE XXX"
        match = re.search(r'prereq/coreq[:]\s*([^.;]+)', text, re.IGNORECASE)
        if match:
            segment = match.group(1)
            course_codes = re.findall(r'\b([A-Z]{2,6})\s*(\d{3}[A-Z]?)\b', segment)
            return [f"{subj} {num}" for subj, num in course_codes]
        return []

class EnhancedPrerequisiteParser:
    """Enhanced parser for prerequisite and antirequisite information from course requirements."""
    
    def __init__(self):
        # Course code pattern: SUBJECT ### (e.g., SYDE 600, ECE 350)
        self.course_pattern = re.compile(r'\b([A-Z]+)\s*(\d+[A-Z]*)\b')
        # Level pattern: Level at least 3A, 4B, etc.
        self.level_pattern = re.compile(r'Level\s+at\s+least\s+(\d+[A-Z]?)\s+([^.;,]+)', re.IGNORECASE)
        # Grade requirements
        self.grade_pattern = re.compile(r'minimum\s+grade\s+of\s+(\w+)', re.IGNORECASE)
        
    def parse_requirements(self, requirements_description: str) -> Dict[str, Any]:
        """
        Parse course requirements description into structured format.
        
        Returns:
            Dict with 'prerequisites', 'antirequisites', 'corequisites', 'level_requirements', etc.
        """
        if not requirements_description:
            return {
                'prerequisites': [],
                'antirequisites': [],
                'corequisites': [],
                'level_requirements': [],
                'grade_requirements': [],
                'other_requirements': []
            }
        
        # Split by major sections
        sections = self._split_requirements(requirements_description)
        
        result = {
            'prerequisites': self._parse_prerequisites(sections.get('prereq', '')),
            'antirequisites': self._parse_antirequisites(sections.get('antireq', '')),
            'corequisites': self._parse_corequisites(sections.get('coreq', '')),
            'level_requirements': self._parse_level_requirements(requirements_description),
            'grade_requirements': self._parse_grade_requirements(requirements_description),
            'other_requirements': self._parse_other_requirements(requirements_description)
        }
        
        return result
    
    def _split_requirements(self, text: str) -> Dict[str, str]:
        """Split requirements text into different sections."""
        sections = {}
        
        # Patterns to identify different sections
        patterns = {
            'prereq': r'Prereq(?:uisite)?[:/]\s*(.*?)(?=Antireq|Coreq|$)',
            'antireq': r'Antireq(?:uisite)?[:/]\s*(.*?)(?=Prereq|Coreq|$)',
            'coreq': r'(?:Prereq/)?[Cc]oreq(?:uisite)?[:/]\s*(.*?)(?=Prereq|Antireq|$)'
        }
        
        for section_name, pattern in patterns.items():
            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if match:
                sections[section_name] = match.group(1).strip()
        
        return sections
    
    def _parse_prerequisites(self, prereq_text: str) -> List[Dict[str, Any]]:
        """Parse prerequisite courses and requirements."""
        if not prereq_text:
            return []
        
        prerequisites = []
        
        # Handle "One of" patterns
        one_of_pattern = r'One\s+of\s+([^.;,]+)'
        one_of_matches = re.finditer(one_of_pattern, prereq_text, re.IGNORECASE)
        
        for match in one_of_matches:
            course_list = match.group(1)
            courses = self._extract_courses(course_list)
            if courses:
                prerequisites.append({
                    'type': 'one_of',
                    'courses': courses,
                    'description': match.group(0)
                })
        
        # Handle direct course requirements
        remaining_text = re.sub(one_of_pattern, '', prereq_text, flags=re.IGNORECASE)
        direct_courses = self._extract_courses(remaining_text)
        
        for course in direct_courses:
            prerequisites.append({
                'type': 'required',
                'courses': [course],
                'description': f"{course['subject']} {course['number']}"
            })
        
        return prerequisites
    
    def _parse_antirequisites(self, antireq_text: str) -> List[str]:
        """Parse antirequisite courses."""
        if not antireq_text:
            return []
        
        courses = self._extract_courses(antireq_text)
        return [f"{course['subject']} {course['number']}" for course in courses]
    
    def _parse_corequisites(self, coreq_text: str) -> List[str]:
        """Parse corequisite courses."""
        if not coreq_text:
            return []
        
        courses = self._extract_courses(coreq_text)
        return [f"{course['subject']} {course['number']}" for course in courses]
    
    def _parse_level_requirements(self, text: str) -> List[Dict[str, str]]:
        """Parse level requirements (e.g., 'Level at least 3A Computer Engineering')."""
        requirements = []
        
        for match in self.level_pattern.finditer(text):
            level = match.group(1)
            program = match.group(2).strip()
            requirements.append({
                'minimum_level': level,
                'program': program
            })
        
        return requirements
    
    def _parse_grade_requirements(self, text: str) -> List[Dict[str, str]]:
        """Parse grade requirements."""
        requirements = []
        
        for match in self.grade_pattern.finditer(text):
            grade = match.group(1)
            requirements.append({
                'minimum_grade': grade
            })
        
        return requirements
    
    def _parse_other_requirements(self, text: str) -> List[str]:
        """Parse other miscellaneous requirements."""
        other_reqs = []
        
        # Instructor consent
        if re.search(r'instructor\s+consent', text, re.IGNORECASE):
            other_reqs.append('Instructor consent required')
        
        # Department consent
        if re.search(r'department\s+consent', text, re.IGNORECASE):
            other_reqs.append('Department consent required')
        
        return other_reqs
    
    def _extract_courses(self, text: str) -> List[Dict[str, str]]:
        """Extract course codes from text."""
        courses = []
        
        # First, find explicit course codes like "SYDE 600", "ECE 350"
        for match in self.course_pattern.finditer(text):
            subject = match.group(1)
            number = match.group(2)
            courses.append({
                'subject': subject,
                'number': number,
                'full_code': f"{subject} {number}"
            })
        
        # Handle implicit course codes like "660A, 660B, 660C" following a subject
        # Look for patterns like "SYDE 660, 660B, 660C" where subsequent numbers share the same subject
        lines = text.split(',')
        current_subject = None
        
        for line in lines:
            line = line.strip()
            
            # Check if this line has a full course code
            full_match = self.course_pattern.search(line)
            if full_match:
                current_subject = full_match.group(1)
                # This is already handled by the main pattern above
                continue
            
            # Check for standalone numbers that should use the current subject
            if current_subject:
                standalone_pattern = re.compile(r'\b(\d+[A-Z]*)\b')
                standalone_matches = standalone_pattern.findall(line)
                
                for number in standalone_matches:
                    # Avoid duplicates
                    full_code = f"{current_subject} {number}"
                    if not any(course['full_code'] == full_code for course in courses):
                        courses.append({
                            'subject': current_subject,
                            'number': number,
                            'full_code': full_code
                        })
        
        return courses

# Engineering Program to Subject Code Mapping
PROGRAM_SUBJECT_MAPPING = {
    "Systems Design Engineering": ["SYDE"],
    "Electrical and Computer Engineering": ["ECE"],
    "Chemical Engineering": ["CHE"],
    "Civil and Environmental Engineering": ["CIVE", "ENVE"],
    "Mechanical and Mechatronics Engineering": ["ME", "MTE"],
    "Management Science and Engineering": ["MSE", "MSCI"]
}

class EngineeringCourseLoader:
    """Load and manage engineering course data for multiple programs with predictive capabilities."""
    
    def __init__(self, base_course_data_dir: Path = DATA_DIR / "course_data_filtered"):
        self.base_course_data_dir = base_course_data_dir
        self.current_program = None
        self.current_subject_codes = []
        self.courses: Dict[str, Course] = {}
        self.course_availability: Dict[str, List[Dict[str, str]]] = defaultdict(list)
        self.prerequisite_parser = PrerequisiteParser()
        self.all_term_files = []

    def load_courses_for_program(self, program_name: str) -> None:
        """Load courses for a specific engineering program."""
        if program_name not in PROGRAM_SUBJECT_MAPPING:
            raise ValueError(f"Program '{program_name}' not supported. Available programs: {list(PROGRAM_SUBJECT_MAPPING.keys())}")
        
        subject_codes = PROGRAM_SUBJECT_MAPPING[program_name]
        
        # Clear existing data if switching programs
        if self.current_program != program_name:
            self.courses.clear()
            self.course_availability.clear()
            self.current_program = program_name
            self.current_subject_codes = subject_codes
        
        print(f"Loading courses for {program_name} (Subject codes: {subject_codes})...")
        
        # Load courses from all relevant subject directories
        for subject_code in subject_codes:
            subject_dir = self.base_course_data_dir / subject_code
            if not subject_dir.exists():
                print(f"Warning: Subject directory not found: {subject_dir}")
                continue
                
            self._load_subject_courses(subject_code, subject_dir)
        
        # Get all term files from the first subject directory for term sequence
        if subject_codes:
            first_subject_dir = self.base_course_data_dir / subject_codes[0]
            if first_subject_dir.exists():
                self.all_term_files = sorted([f.stem for f in first_subject_dir.glob("*.json")], reverse=True)
        
        print(f"Loaded {len(self.courses)} unique courses for {program_name}")

    def _load_subject_courses(self, subject_code: str, subject_dir: Path) -> None:
        """Load courses for a specific subject."""
        for json_file in subject_dir.glob("*.json"):
            term_code = json_file.stem
            try:
                with open(json_file, 'r', encoding='utf-8') as f:
                    term_courses_data = json.load(f)
                
                for course_data in term_courses_data:
                    course = Course(
                        course_id=course_data.get('courseId', ''),
                        subject_code=course_data.get('subjectCode', ''),
                        catalog_number=course_data.get('catalogNumber', ''),
                        title=course_data.get('title', ''),
                        description=course_data.get('description', ''),
                        credit_weight=float(course_data.get('creditWeight', 0.5)),
                        requirements_description=course_data.get('requirementsDescription'),
                        term_code=course_data.get('termCode', ''),
                        term_name=course_data.get('termName', ''),
                        academic_career=course_data.get('associatedAcademicCareer', '')
                    )
                    
                    course_code = course.course_code
                    if course_code not in self.courses:
                        self.courses[course_code] = course
                    
                    self.course_availability[course_code].append({
                        "term_code": term_code,
                        "term_name": course.term_name
                    })
            except Exception as e:
                print(f"Error loading {json_file}: {e}")

    def get_course(self, course_code: str) -> Optional[Course]:
        """Get course by course code"""
        return self.courses.get(course_code)

    def get_course_availability(self, course_code: str) -> List[Dict[str, str]]:
        """Get all terms when a course was offered"""
        return self.course_availability.get(course_code, [])

    def get_offering_status_for_term(self, course_code: str, term_code: str) -> Dict[str, Any]:
        """
        Get offering status for a specific course in a specific term.
        Returns dictionary with 'is_offered' boolean and 'status' string.
        """
        availability = self.course_availability.get(course_code, [])
        for offering in availability:
            if offering["term_code"] == term_code:
                return {"is_offered": True, "status": "Confirmed"}
        
        # If not directly offered, try to predict based on historical patterns
        return self._predict_course_offering(course_code, term_code)

    def _predict_course_offering(self, course_code: str, term_code: str) -> Dict[str, Any]:
        """Predict if a course will be offered in a given term based on historical patterns."""
        availability = self.course_availability.get(course_code, [])
        if not availability:
            return {"is_offered": False, "status": "No historical data"}

        # Analyze historical offering patterns
        term_patterns = defaultdict(int)
        for offering in availability:
            historical_term = offering["term_code"]
            if len(historical_term) == 4:  # Format: YYSM where S=season, M=month
                season_month = historical_term[2:]
                term_patterns[season_month] += 1

        # Extract season/month from target term
        if len(term_code) == 4:
            target_season_month = term_code[2:]
            if target_season_month in term_patterns:
                confidence = term_patterns[target_season_month] / len(availability)
                if confidence >= 0.6:  # 60% confidence threshold
                    return {"is_offered": True, "status": f"Predicted (Historical: {confidence:.0%})"}
                else:
                    return {"is_offered": False, "status": f"Unlikely (Historical: {confidence:.0%})"}

        return {"is_offered": False, "status": "Cannot predict"}

    def get_all_courses(self) -> List[Course]:
        """Get all loaded courses"""
        return list(self.courses.values())

    def get_courses_by_subject(self, subject_code: str) -> List[Course]:
        """Get all courses for a specific subject"""
        return [course for course in self.courses.values() if course.subject_code == subject_code]

    def get_current_program_info(self) -> Dict[str, Any]:
        """Get information about currently loaded program"""
        return {
            "program_name": self.current_program,
            "subject_codes": self.current_subject_codes,
            "total_courses": len(self.courses),
            "available_terms": self.all_term_files
        }
    
    def get_courses_by_level(self, level_range: Tuple[int, int]) -> List[Course]:
        """Get courses within a specific level range"""
        courses = []
        for course in self.courses.values():
            try:
                level = int(course.catalog_number[:1])
                if level_range[0] <= level <= level_range[1]:
                    courses.append(course)
            except (ValueError, IndexError):
                continue
        return courses

    def get_offering_status_for_term(self, course_code: str, target_term_code: str) -> Dict[str, Any]:
        """Check and predict if a course is offered in a specific term."""
        
        # 1. Check for confirmed offering
        for offering in self.course_availability.get(course_code, []):
            if offering["term_code"] == target_term_code:
                return {"is_offered": True, "status": "Confirmed"}

        # 2. If target term is in the future, try to predict
        if target_term_code > self.all_term_files[0]:
            target_year = int(target_term_code[:-1])
            target_season = target_term_code[-1]
            
            # Look at the last 3 years for the same season
            historical_offerings = []
            for i in range(1, 4):
                past_year = str(target_year - i)
                past_term_code = past_year + target_season
                if any(o["term_code"] == past_term_code for o in self.course_availability.get(course_code, [])):
                    historical_offerings.append(True)
                else:
                    historical_offerings.append(False)
            
            if historical_offerings[0]:
                return {"is_offered": True, "status": "Predicted (Annual)"}
            if historical_offerings[1]:
                return {"is_offered": True, "status": "Predicted (Likely Biennial)"}
            if any(historical_offerings):
                 return {"is_offered": True, "status": "Predicted (Sporadic)"}

        return {"is_offered": False, "status": "Not Offered"}

class EngineeringProgramLoader:
    """Load and manage engineering program data using unified format"""
    
    def __init__(self, unified_programs_file: Path = DATA_DIR / "engineering_programs_unified.json"):
        self.unified_programs_file = unified_programs_file
        self.programs: Dict[str, Dict] = {}
        self.department_subject_mapping: Dict[str, List[str]] = {}
        
    def load_programs(self) -> None:
        """Load all engineering programs from unified JSON file"""
        if not self.unified_programs_file.exists():
            # Fallback to old format loading
            self._load_legacy_format()
            return
        
        with open(self.unified_programs_file, 'r', encoding='utf-8') as f:
            unified_data = json.load(f)
        
        # Load department-subject mapping
        self.department_subject_mapping = unified_data.get("department_subject_mapping", {})
        
        # Load programs
        programs_list = unified_data.get("programs", [])
        for program in programs_list:
            department = program["department"]
            self.programs[department] = program
        
        print(f"Loaded {len(self.programs)} engineering programs from unified format")
    
    def _load_legacy_format(self) -> None:
        """Fallback to load old format from program_data directory"""
        program_data_dir = DATA_DIR / "program_data"
        if not program_data_dir.exists():
            raise FileNotFoundError(f"Neither unified programs file nor program data directory found")
        
        program_files = {
            "Systems Design Engineering": "System Design MEng.json",
            "Electrical and Computer Engineering": "ece.json", 
            "Chemical Engineering": "Chemical_Engineering.json",
            "Civil and Environmental Engineering": "Civil and Environmental Engineering.json",
            "Mechanical and Mechatronics Engineering": "Mechanical and Mechatronics Engineering.json",
            "Management Science and Engineering": "Management Science and Engineering.json"
        }
        
        for program_name, filename in program_files.items():
            file_path = program_data_dir / filename
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    program_data = json.load(f)
                    
                    # Check if this is enhanced format (has _program_info)
                    if "_program_info" in program_data:
                        # Enhanced format - extract specializations from top-level keys
                        program_info = program_data.get("_program_info", {})
                        specializations = {}
                        
                        # Extract all non-metadata keys as specializations
                        for key, value in program_data.items():
                            if not key.startswith("_"):  # Skip metadata fields
                                specializations[key] = value
                        
                        self.programs[program_name] = {
                            "program_name": program_info.get("program_name", f"Master of Engineering (MEng) in {program_name}"),
                            "department": program_name,
                            "specializations": specializations,
                            "program_info": program_info,
                            "degree_constraints": program_data.get("_degree_constraints", {}),
                            "milestone_requirements": program_data.get("_milestone_requirements", {}),
                            "specialization_info": program_data.get("_specialization_info", {})
                        }
                    elif "degree_rules" in program_data:
                        # SYDE structured format - use directly
                        program_data["department"] = program_name
                        self.programs[program_name] = program_data
                    else:
                        # Old format - wrap in structure
                        self.programs[program_name] = {
                            "program_name": f"Master of Engineering (MEng) in {program_name}",
                            "department": program_name,
                            "specializations": program_data
                        }
        
        print(f"Loaded {len(self.programs)} engineering programs from legacy format")
    
    def get_program(self, program_name: str) -> Optional[Dict]:
        """Get a specific program by name"""
        for key, program in self.programs.items():
            if key == program_name or program["program_name"] == program_name:
                return program
        return None
    
    def get_all_programs(self) -> List[str]:
        """Get list of all available program names"""
        return list(self.programs.keys())
    
    def get_specializations(self, program_name: str) -> List[str]:
        """Get list of specializations for a program"""
        program = self.get_program(program_name)
        if program and "specializations" in program:
            specializations = program["specializations"]
            
            # Handle new structured format (list of specialization objects)
            if isinstance(specializations, list):
                return [spec.get("name", "") for spec in specializations if spec.get("name")]
            
            # Handle old format (dictionary)
            elif isinstance(specializations, dict):
                return list(specializations.keys())
        
        return []

class SYDEProgramLoader:
    """Load and manage SYDE program requirements"""
    
    def __init__(self, programs_file: Path = DATA_DIR / "syde_programs_structured.json"):
        self.programs_file = programs_file
        self.programs: List[Dict] = []
        
    def load_programs(self) -> None:
        """Load SYDE program data"""
        if not self.programs_file.exists():
            raise FileNotFoundError(f"Programs file not found: {self.programs_file}")
        
        with open(self.programs_file, 'r', encoding='utf-8') as f:
            self.programs = json.load(f)
        
        print(f"Loaded {len(self.programs)} SYDE programs")
    
    def get_program(self, degree: str, specialization: str = None) -> Optional[Dict]:
        """Get program requirements by degree and specialization"""
        for program in self.programs:
            program_name = program.get('program_name', '').lower()
            
            # Match degree type
            if degree.lower() not in program_name:
                continue
            
            # If no specialization specified, return base program
            if not specialization:
                if 'specializations' not in program:
                    return program
                continue
            
            # Match specialization
            if 'specializations' in program:
                for spec in program['specializations']:
                    if specialization.lower() in spec.get('name', '').lower():
                        # Merge base program with specialization
                        merged_program = program.copy()
                        merged_program['active_specialization'] = spec
                        return merged_program
        
        return None

class SYDECoursePlanner:
    """Main course planning engine for SYDE students."""
    
    def __init__(self):
        self.course_loader = EngineeringCourseLoader()
        self.program_loader = SYDEProgramLoader()
        self.engineering_program_loader = EngineeringProgramLoader()
        self.course_validator = None  # Initialize after course_loader
        self.term_manager = TermSequenceManager()
        self.requirements_formatter = RequirementsFormatter()
        
    def initialize(self) -> None:
        """Initialize the planner by loading data."""
        print("Initializing SYDE Course Planner...")
        self.course_loader.load_courses_for_program("Systems Design Engineering") # Default to SYDE for now
        self.program_loader.load_programs()
        self.engineering_program_loader.load_programs()
        
        # Initialize course validator after course loader
        self.course_validator = CourseValidator(self.course_loader)
        print("Initialization complete!\n")
    
    def switch_program(self, program_name: str) -> Dict[str, Any]:
        """Switch to a different engineering program and reload course data."""
        try:
            print(f"Switching to program: {program_name}")
            self.course_loader.load_courses_for_program(program_name)
            
            # Reinitialize course validator with new course data
            self.course_validator = CourseValidator(self.course_loader)
            
            return {
                "success": True,
                "message": f"Successfully switched to {program_name}",
                "program_info": self.course_loader.get_current_program_info()
            }
        except Exception as e:
            return {
                "success": False,
                "error": f"Failed to switch program: {str(e)}"
            }
    
    def plan_courses(self, user_input: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generates the necessary data for the frontend planning board.
        
        Args:
            user_input: {
                'degree': 'MEng',
                'semesters': 3,
                'specialization': '...',
                'start_term': '1249' // e.g., Fall 2024
            }
        
        Returns:
            A dictionary containing the course pool and an empty semester structure.
        """
        
        # Check if using new program format or legacy format
        if 'program' in user_input:
            # New format: use engineering program loader
            program = self.engineering_program_loader.get_program(user_input['program'])
            if not program:
                return {"error": "Program not found"}
            
            # Parse requirements for new format
            requirements = self._parse_engineering_program_requirements(program, user_input)
        else:
            # Legacy format: use SYDE program loader
            program = self.program_loader.get_program(
                user_input['degree'], 
                user_input.get('specialization')
            )
            
            if not program:
                available_programs = [p['program_name'] for p in self.program_loader.programs]
                return {
                    'error': f"Program not found for degree: {user_input['degree']}, specialization: {user_input.get('specialization')}",
                    'available_programs': available_programs
                }
            
            requirements = self._parse_program_requirements(program, user_input)
        
        # Generate the user's study schedule
        user_schedule = self._generate_semester_schedule_codes(
            user_input['start_term'], 
            user_input['semesters']
        )
        
        course_pool = self._build_course_pool(requirements, user_schedule)
        
        # Generate the semester structure for the frontend
        semester_structure = self._generate_semester_structure(
            user_input['start_term'], 
            user_input['semesters']
        )
        
        # Format requirements summary for better display
        formatted_requirements = self.requirements_formatter.format_requirements_summary(
            requirements, 
            user_input.get('specialization')
        )
        
        plan = {
            'program_info': {
                'program_name': program.get('program_name', f"Master of Engineering in {user_input.get('program', '')}"),
                'specialization': user_input.get('specialization'),
            },
            'requirements_summary': requirements,  # Keep original for API compatibility
            'formatted_requirements': formatted_requirements,  # New structured format
            'course_pool': course_pool,
            'semester_structure': semester_structure,
        }
        
        return plan
    
    def validate_move(self, course_code: str, term_code: str, current_plan: Dict[str, List[str]] = None, 
                     program_context: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Validate if a course can be moved to a specific term.
        
        Args:
            course_code: Course to validate (e.g., "SYDE 660")
            term_code: Target term code (e.g., "1255")
            current_plan: Dict mapping term_code -> list of course codes in current plan
            program_context: Dict with program and specialization info for validating program requirements
            
        Returns:
            Validation result with success status and detailed information
        """
        if not self.course_validator:
            return {
                'valid': False,
                'error': 'Course validator not initialized'
            }
        
        # For validation, we need to properly distinguish between completed and planned courses
        # In this context, current_plan contains the courses currently placed in semesters
        # We'll treat all courses as planned since this is a planning tool
        planned_courses = current_plan or {}
        completed_courses = {}  # In a real system, this would contain actually completed courses
        
        validation_result = self.course_validator.validate_course_placement(
            course_code=course_code,
            target_term=term_code,
            completed_courses=completed_courses,
            planned_courses=planned_courses
        )
        
        # Add program-specific validation if context is provided
        if program_context:
            program_validation = self._validate_program_requirements(course_code, program_context)
            if not program_validation['valid']:
                validation_result['valid'] = False
                validation_result['issues'].extend(program_validation['issues'])
            validation_result['warnings'].extend(program_validation.get('warnings', []))
        
        # Get course information for additional context
        course = self.course_loader.get_course(course_code)
        if course:
            validation_result['course_info'] = {
                'title': course.title,
                'description': course.description,
                'requirements_description': course.requirements_description,
                'credit_weight': course.credit_weight
            }
        
        # Add offering status
        offering_status = self.course_loader.get_offering_status_for_term(course_code, term_code)
        validation_result['offering_status'] = offering_status
        
        return validation_result

    def _generate_semester_schedule_codes(self, start_term_code: str, num_semesters: int) -> List[str]:
        """Generates a list of term codes for the student's study period."""
        codes = []
        current_term = start_term_code
        for _ in range(num_semesters):
            codes.append(current_term)
            year_code = int(current_term[:-1])
            term_digit = int(current_term[-1])
            if term_digit == 9: # Fall
                current_term = str(year_code + 1) + '1'
            else:
                current_term = str(year_code) + str(term_digit + 4)
        return codes

    def _generate_semester_structure(self, start_term_code: str, num_semesters: int) -> List[Dict[str, str]]:
        """Creates a list of semester objects for the frontend planning board."""
        structure = []
        current_term = start_term_code
        
        term_map = {1: "Winter", 5: "Spring", 9: "Fall"}

        for _ in range(num_semesters):
            year = 1900 + int(current_term[:-1])
            season_digit = int(current_term[-1])
            
            structure.append({
                "term_code": current_term,
                "term_name": f"{term_map[season_digit]} {year}",
                "name": f"{term_map[season_digit]} {year}",
                "capacity": 3,  # Default capacity for MEng programs
                "courses": []
            })
            
            # Calculate next term
            if season_digit == 9: # Fall
                current_term = str(int(current_term[:-1]) + 1) + '1' # Next Winter
            else:
                current_term = current_term[:-1] + str(season_digit + 4)
                
        return structure

    def _parse_program_requirements(self, program: Dict, user_input: Dict) -> Dict[str, Any]:
        """Parse program requirements into structured format, handling duplicates."""
        degree_rules = program.get('degree_rules', {})
        
        # Use sets for automatic deduplication
        compulsory_courses = set(degree_rules.get('compulsory_courses', []))
        
        # Use a dictionary to store choice groups by name to avoid duplicates
        compulsory_choices = {choice['group_name']: choice for choice in degree_rules.get('compulsory_choices', [])}

        elective_requirements = {rule.get('group_name', rule.get('type')): rule for rule in degree_rules.get('elective_rules', [])}

        # Handle specialization requirements
        if 'active_specialization' in program:
            spec = program['active_specialization']
            spec_req = spec.get('requirements', {})
            
            # Add specialization compulsory courses
            compulsory_courses.update(spec_req.get('compulsory_courses', []))
            
            # Add/overwrite specialization choices
            for choice in spec_req.get('compulsory_choices', []):
                compulsory_choices[choice['group_name']] = choice

            # Add/overwrite elective rules
            for rule in spec_req.get('elective_rules', []):
                elective_requirements[rule.get('group_name', rule.get('type'))] = rule

        return {
            'total_courses': program.get('degree_rules', {}).get('total_courses', 8), # Default to 8 for MEng
            'compulsory_courses': sorted(list(compulsory_courses)),
            'compulsory_choices': list(compulsory_choices.values()),
            'elective_requirements': list(elective_requirements.values()),
            'constraints': {
                'level_constraints': degree_rules.get('level_constraints', {}),
                'departmental_constraints': degree_rules.get('departmental_constraints', {})
            }
        }

    def _parse_engineering_program_requirements(self, program: Dict, user_input: Dict) -> Dict[str, Any]:
        """Parse engineering program requirements from new structured format"""
        # Handle new structured format
        if 'degree_rules' in program:
            return self._parse_new_structured_program(program, user_input)
        
        # Fallback to old format
        return self._parse_old_format_program(program, user_input)
    
    def _parse_new_structured_program(self, program: Dict, user_input: Dict) -> Dict[str, Any]:
        """Parse new structured program format"""
        degree_rules = program.get('degree_rules', {})
        
        # Start with base program requirements
        compulsory_courses = []
        compulsory_choices = []
        elective_requirements = []
        
        # Process base degree requirements
        for req in degree_rules.get('requirements', []):
            if req['type'] == 'compulsory':
                compulsory_courses.extend(req['courses'])
            elif req['type'] == 'compulsory_choice':
                compulsory_choices.append({
                    'n_to_choose': req['n_to_choose'],
                    'group_name': req.get('description', 'Choice Group'),
                    'courses': req['courses']
                })
            elif req['type'] == 'elective':
                elective_requirements.append({
                    'type': 'elective',
                    'group_name': req.get('description', 'General Electives'),
                    'n_to_choose': req['n_to_choose'],
                    'courses': req.get('courses', [])
                })
        
        # Add specialization requirements if specified
        if 'specialization' in user_input:
            specialization_name = user_input['specialization'].replace('_', ' ')
            specializations = program.get('specializations', [])
            
            for spec in specializations:
                if spec.get('name') == specialization_name:
                    # Process specialization requirements
                    for req in spec.get('requirements', []):
                        if req['type'] == 'specified':
                            compulsory_courses.extend(req['courses'])
                        elif req['type'] == 'specified_choice':
                            compulsory_choices.append({
                                'n_to_choose': req['n_to_choose'],
                                'group_name': req.get('description', 'Specialization Choice'),
                                'courses': req['courses']
                            })
                        elif req['type'] == 'elective':
                            elective_requirements.append({
                                'type': 'elective',
                                'group_name': req.get('description', 'Specialization Electives'),
                                'n_to_choose': req['n_to_choose'],
                                'courses': req['courses']
                            })
                    break
        
        return {
            'total_courses': degree_rules.get('total_courses', 8),
            'compulsory_courses': list(set(compulsory_courses)),
            'compulsory_choices': compulsory_choices,
            'elective_requirements': elective_requirements,
            'constraints': {
                'level_constraints': degree_rules.get('level_constraints', {}),
                'departmental_constraints': degree_rules.get('departmental_constraints', {})
            }
        }
    
    def _parse_old_format_program(self, program: Dict, user_input: Dict) -> Dict[str, Any]:
        """Parse old format program requirements (fallback)"""
        specializations = program.get('specializations', {})
        
        # Get base program requirements (if any)
        base_key = f"{program['department'].replace(' ', '_')}_MEng"
        base_req = specializations.get(base_key, {})
        
        # Get specialization requirements
        spec_req = {}
        if 'specialization' in user_input:
            spec_key = user_input['specialization'].replace(' ', '_')
            spec_req = specializations.get(spec_key, {})
        
        # Combine requirements
        compulsory_courses = []
        compulsory_choices = []
        elective_requirements = []
        
        # Process base requirements
        if base_req:
            compulsory_courses.extend(self._extract_course_codes(base_req.get('specified_fixed', [])))
            compulsory_choices.extend(self._parse_specified_choose(base_req.get('specified_choose', [])))
            if 'elective' in base_req:
                elective_requirements.append({
                    'type': 'elective',
                    'group_name': 'Base Electives',
                    'n_to_choose': base_req['elective'].get('min_count', 1),
                    'description': base_req['elective'].get('note', '')
                })
        
        # Process specialization requirements
        if spec_req:
            compulsory_courses.extend(self._extract_course_codes(spec_req.get('specified_fixed', [])))
            compulsory_choices.extend(self._parse_specified_choose(spec_req.get('specified_choose', [])))
            if 'elective' in spec_req:
                elective_requirements.append({
                    'type': 'elective',
                    'group_name': 'Specialization Electives',
                    'n_to_choose': spec_req['elective'].get('min_count', 1),
                    'courses': spec_req['elective'].get('list', [])
                })
        
        return {
            'total_courses': 8,  # Default for MEng
            'compulsory_courses': list(set(compulsory_courses)),
            'compulsory_choices': compulsory_choices,
            'elective_requirements': elective_requirements,
            'constraints': {}
        }
    
    def _extract_course_codes(self, course_list: List[str]) -> List[str]:
        """Extract course codes from course descriptions"""
        import re
        codes = []
        for course in course_list:
            # Extract course code from descriptions like "SYDE 600 - Systems Theory..."
            match = re.match(r'([A-Z]{2,6}\s+\d{3}[A-Z]?)', course)
            if match:
                codes.append(match.group(1))
        return codes
    
    def _parse_specified_choose(self, choose_list: List[Dict]) -> List[Dict]:
        """Parse specified_choose requirements"""
        choices = []
        for choice in choose_list:
            if 'count' in choice and 'options' in choice:
                choices.append({
                    'n_to_choose': choice['count'],
                    'group_name': f"Choose {choice['count']} from options",
                    'courses': self._extract_course_codes(choice['options'])
                })
        return choices

    def _build_course_pool(self, requirements: Dict, user_schedule: List[str]) -> List[Dict]:
        """
        Build a pool of courses that are relevant and available during the student's schedule.
        """
        course_pool = []
        
        # Helper to create a course item for the pool
        def create_pool_item(course: Course, category: str, priority: int, rule: Optional[Dict] = None):
            if not course: return None

            # --- Smart Availability Check ---
            is_available_in_schedule = False
            availability_notes = []
            for term_code in user_schedule:
                status = self.course_loader.get_offering_status_for_term(course.course_code, term_code)
                if status["is_offered"]:
                    is_available_in_schedule = True
                    availability_notes.append(f"{term_code}: {status['status']}")
            
            # Only add course to the pool if it's available at some point during the user's study period
            if not is_available_in_schedule:
                return None

            # Parse course requirements for prerequisite/antirequisite display
            prereq_parser = EnhancedPrerequisiteParser()
            parsed_requirements = prereq_parser.parse_requirements(course.requirements_description)

            course_dict = asdict(course)
            course_dict['course_code'] = course.course_code
            
            # Keep nested structure for frontend compatibility
            return {
                'course': course_dict,
                'category': category,
                'priority': priority,
                'availability_notes': availability_notes,
                'elective_rule': rule,
                'prerequisites': parsed_requirements.get('prerequisites', []),
                'antirequisites': parsed_requirements.get('antirequisites', []),
                'corequisites': parsed_requirements.get('corequisites', []),
                'level_requirements': parsed_requirements.get('level_requirements', []),
                'other_requirements': parsed_requirements.get('other_requirements', [])
            }

        all_courses_from_rules = set(requirements.get('compulsory_courses', []))
        for choice in requirements.get('compulsory_choices', []):
            all_courses_from_rules.update(choice.get('courses', []))
        for elective_rule in requirements.get('elective_requirements', []):
            all_courses_from_rules.update(elective_rule.get('courses', []))
            all_courses_from_rules.update(elective_rule.get('specified_list', []))
            all_courses_from_rules.update(elective_rule.get('elective_list', []))

        # Process all courses mentioned in rules with proper categorization
        for course_code in all_courses_from_rules:
            course = self.course_loader.get_course(course_code)
            if course:
                # Determine category and priority based on requirements
                category, priority = self._categorize_course(course_code, requirements)
                item = create_pool_item(course, category, priority)
                if item: 
                    # Add requirement tags and visual formatting
                    item['tags'] = self._get_course_tags(course_code, requirements)
                    item['tag'], item['tag_color'] = self._get_course_tag_and_color(course_code, requirements)
                    course_pool.append(item)
            
        # Add general graduate courses
        existing_codes = {item['course']['course_code'] for item in course_pool}
        graduate_courses = self.course_loader.get_courses_by_level((6, 9))
        for course in graduate_courses:
            if course.course_code not in existing_codes:
                item = create_pool_item(course, 'general_elective', 5)
                if item: 
                    # Add tags for general graduate courses
                    item['tags'] = self._get_course_tags(course.course_code, requirements)
                    item['tag'], item['tag_color'] = self._get_course_tag_and_color(course.course_code, requirements)
                    course_pool.append(item)
        
        # Deduplicate and sort with improved logic
        final_pool = {item['course']['course_code']: item for item in course_pool}.values()
        return sorted(list(final_pool), key=self._course_sort_key, reverse=False)  # False for ascending order

    def _get_course_level(self, course_code: str) -> int:
        """Get the level of a course from its course code."""
        import re
        match = re.search(r'(\d)(?:\d{2})', course_code)
        if match:
            return int(match.group(1))
        return 0

    def _categorize_course(self, course_code: str, requirements: Dict) -> Tuple[str, int]:
        """Categorize a course and assign priority based on requirements."""
        # Check if it's compulsory
        if course_code in requirements.get('compulsory_courses', []):
            return 'compulsory', 10
        
        # Check if it's in compulsory choices
        for choice_group in requirements.get('compulsory_choices', []):
            if course_code in choice_group.get('courses', []):
                return 'compulsory_choice', 9
        
        # Check if it's in elective requirements
        for elective_group in requirements.get('elective_requirements', []):
            if course_code in elective_group.get('courses', []):
                return 'specified_elective', 8
            if course_code in elective_group.get('specified_list', []):
                return 'specified_elective', 7
            if course_code in elective_group.get('elective_list', []):
                return 'general_elective', 6
        
        # Default category
        return 'general_elective', 5

    def _get_course_tags(self, course_code: str, requirements: Dict) -> List[str]:
        """Get tags for a course based on its role in requirements."""
        tags = []
        
        # Check if it's compulsory
        if course_code in requirements.get('compulsory_courses', []):
            tags.append('Required')
            tags.append('Core')
        
        # Check if it's in compulsory choices
        for choice_group in requirements.get('compulsory_choices', []):
            if course_code in choice_group.get('courses', []):
                tags.append('Choice Required')
                n_to_choose = choice_group.get('n_to_choose', 1)
                tags.append(f'Choose {n_to_choose}')
        
        # Check if it's in elective requirements
        for elective_group in requirements.get('elective_requirements', []):
            group_name = elective_group.get('group_name', 'Elective')
            if course_code in elective_group.get('courses', []):
                tags.append('Elective')
                tags.append(group_name)
            elif course_code in elective_group.get('specified_list', []):
                tags.append('Specified Elective')
                tags.append(group_name)
            elif course_code in elective_group.get('elective_list', []):
                tags.append('General Elective')
        
        # Add level tags
        course_level = self._get_course_level(course_code)
        if course_level >= 6:
            tags.append('Graduate Level')
        elif course_level == 5:
            tags.append('Advanced Undergraduate')
        
        return tags

    def _get_course_tag_and_color(self, course_code: str, requirements: Dict) -> Tuple[str, str]:
        """Get the primary tag and color for a course based on its requirements role."""
        # Check if it's compulsory
        if course_code in requirements.get('compulsory_courses', []):
            return 'Required', '#dc3545'  # Red
        
        # Check if it's in compulsory choices
        for choice_group in requirements.get('compulsory_choices', []):
            if course_code in choice_group.get('courses', []):
                return 'Core', '#fd7e14'  # Orange
        
        # Check if it's in elective requirements (specified courses)
        for elective_group in requirements.get('elective_requirements', []):
            if course_code in elective_group.get('courses', []):
                return 'Elective', '#28a745'  # Green
        
        # Check course level for graduate designation
        course_level = self._get_course_level(course_code)
        if course_level >= 6:
            return 'Graduate', '#6f42c1'  # Purple
        elif course_level == 5:
            return 'Advanced', '#17a2b8'  # Teal
        
        return 'General', '#6c757d'  # Gray

    def _course_sort_key(self, course_item: Dict) -> Tuple:
        """
        Generate a sort key for course ordering.
        Lower values appear first.
        Priority order: Required -> Core -> Choice Required -> Specified Elective -> General Elective
        """
        course_code = course_item['course']['course_code']
        priority = course_item['priority']
        category = course_item['category']
        tags = course_item.get('tags', [])
        
        # Extract course number for numerical sorting within same subject
        import re
        match = re.search(r'([A-Z]+)\s*(\d+)', course_code)
        subject = match.group(1) if match else 'ZZZ'
        number = int(match.group(2)) if match else 9999
        
        # Primary sort: by course importance (Required first, then Core, etc.)
        # Determine sort priority based on tags for better clarity
        if 'Required' in tags:
            sort_priority = 1  # Highest priority - Required courses
        elif category == 'compulsory':
            sort_priority = 2  # Core required courses
        elif 'Choice Required' in tags or category == 'compulsory_choice':
            sort_priority = 3  # Must choose from these courses
        elif 'Specified Elective' in tags or category == 'specified_elective':
            sort_priority = 4  # Specific elective courses
        elif 'Elective' in tags or category in ['general_elective', 'elective']:
            sort_priority = 5  # General electives
        else:
            sort_priority = 6  # Other courses
        
        # Secondary sort: SYDE courses first, then others
        subject_priority = 0 if subject == 'SYDE' else 1
        
        # Tertiary sort: by course level (graduate courses first)
        course_level = self._get_course_level(course_code)
        level_priority = 0 if course_level >= 6 else 1  # Graduate first
        
        # Quaternary sort: by course number within same subject
        # Lower numbers first (e.g., SYDE 600 before SYDE 660)
        
        return (sort_priority, subject_priority, level_priority, subject, number)

    def _validate_program_requirements(self, course_code: str, program_context: Dict[str, Any]) -> Dict[str, Any]:
        """Validate if a course meets program-specific requirements"""
        program_name = program_context.get('program', '')
        specialization = program_context.get('specialization', '')
        
        # Get program data
        program = self.program_loader.get_program('engineering', specialization)
        if not program:
            return {'valid': True, 'issues': [], 'warnings': []}
        
        # Parse requirements
        requirements = self._parse_program_requirements(program, program_context)
        
        # Check if this course conflicts with specialization requirements
        validation_issues = []
        warnings = []
        
        # Check for Graduate Workshop 1 requirement (SYDE 660 series)
        if course_code.startswith('SYDE 660') and specialization:
            # Check if this specialization has specific compulsory courses that override the general choice
            compulsory_courses = requirements.get('compulsory_courses', [])
            
            # Check if a specific 660 variant is required by the specialization
            required_660_variant = None
            for course in compulsory_courses:
                if course.startswith('SYDE 660') and course != 'SYDE 660':
                    required_660_variant = course
                    break
            
            if required_660_variant and course_code != required_660_variant:
                specialization_name = specialization.replace('_', ' ')
                if 'Artificial Intelligence' in specialization:
                    validation_issues.append(
                        f"For AI/ML specialization, you must take SYDE 660A (Systems Design Graduate Workshop 1 - AI and Machine Learning), not {course_code}"
                    )
                elif 'Biomedical' in specialization:
                    validation_issues.append(
                        f"For Biomedical Systems specialization, you must take SYDE 660B (Systems Design Graduate Workshop 1 - Biomedical Systems), not {course_code}"
                    )
                elif 'Human Factors' in specialization:
                    validation_issues.append(
                        f"For Human Factors specialization, you must take SYDE 660C (Systems Design Graduate Workshop 1 - Human Factors), not {course_code}"
                    )
                elif 'Mechatronic' in specialization:
                    validation_issues.append(
                        f"For Mechatronic and Physical Systems specialization, you must take SYDE 660D (Systems Design Graduate Workshop 1 - Mechatronic & Physical Systems), not {course_code}"
                    )
                elif 'Vision' in specialization or 'Image' in specialization:
                    validation_issues.append(
                        f"For Vision, Image and Signal Processing specialization, you must take SYDE 660E (Systems Design Graduate Workshop 1 - Vision, Image & Signal Processing), not {course_code}"
                    )
                else:
                    validation_issues.append(
                        f"For {specialization_name} specialization, you must take {required_660_variant}, not {course_code}"
                    )
        
        return {
            'valid': len(validation_issues) == 0,
            'issues': validation_issues,
            'warnings': warnings
        }

    def _generate_recommendations(self, course_pool: List[Dict], requirements: Dict) -> List[str]:
        """Generate planning recommendations"""
        recommendations = []
        
        # Check for compulsory courses
        compulsory_count = sum(1 for item in course_pool if item['category'] == 'compulsory')
        if compulsory_count > 0:
            recommendations.append(f"Complete {compulsory_count} compulsory course(s) first")
        
        # Check for choice requirements
        choice_groups = set()
        for item in course_pool:
            if item['category'] == 'compulsory_choice':
                choice_groups.add(str(item.get('choice_group', {})))
        
        if choice_groups:
            recommendations.append(f"Select from {len(choice_groups)} required choice group(s)")
        
        # Level constraints
        level_constraints = requirements.get('constraints', {}).get('level_constraints', {})
        if 'max_500_level' in level_constraints:
            max_500 = level_constraints['max_500_level']
            recommendations.append(f"Maximum {max_500} course(s) at 500-level allowed")
        
        # Departmental constraints
        dept_constraints = requirements.get('constraints', {}).get('departmental_constraints', {})
        if 'min_syde_courses' in dept_constraints:
            min_syde = dept_constraints['min_syde_courses']
            recommendations.append(f"Minimum {min_syde} SYDE course(s) required")
        
        return recommendations

    def _add_elective_courses(self, course_pool: List[Dict], requirements: Dict) -> None:
        """Add elective courses based on specialization requirements"""
        for elective_rule in requirements.get('elective_requirements', []):
            if elective_rule.get('type') == 'choose_n_from_list':
                for course_code in elective_rule.get('courses', []):
                    course = self.course_loader.get_course(course_code)
                    if course:
                        course_dict = asdict(course)
                        course_dict['course_code'] = course.course_code
                        course_pool.append({
                            'course': course_dict,
                            'category': 'specified_elective',
                            'elective_rule': elective_rule,
                            'priority': 7,
                            'availability': self.course_loader.get_offering_status_for_term(course_code, '1249') # Placeholder for now
                        })
            
            elif elective_rule.get('type') == 'complex':
                # Handle complex elective rules (specified + elective lists)
                for list_name in ['specified_list', 'elective_list']:
                    if list_name in elective_rule:
                        priority = 8 if list_name == 'specified_list' else 6
                        for course_code in elective_rule[list_name]:
                            course = self.course_loader.get_course(course_code)
                            if course:
                                course_dict = asdict(course)
                                course_dict['course_code'] = course.course_code
                                course_pool.append({
                                    'course': course_dict,
                                    'category': f'complex_{list_name}',
                                    'elective_rule': elective_rule,
                                    'priority': priority,
                                    'availability': self.course_loader.get_offering_status_for_term(course_code, '1249') # Placeholder for now
                                })

class CourseValidator:
    """Validates course prerequisites and constraints for a student's course plan."""
    
    def __init__(self, course_loader: 'EngineeringCourseLoader'):
        self.course_loader = course_loader
        self.prereq_parser = EnhancedPrerequisiteParser()

    def _get_course_level(self, course_code: str) -> int:
        """Get the level of a course from its course code."""
        import re
        match = re.search(r'(\d)(?:\d{2})', course_code)
        if match:
            return int(match.group(1))
        return 0
        
    def validate_course_placement(self, 
                                course_code: str, 
                                target_term: str, 
                                completed_courses: Dict[str, List[str]],
                                planned_courses: Dict[str, List[str]] = None,
                                max_courses_per_term: int = 3) -> Dict[str, Any]:
        """
        Validate if a course can be placed in a specific term.
        
        Args:
            course_code: Course to validate (e.g., "SYDE 660")
            target_term: Term code (e.g., "1255") 
            completed_courses: Dict mapping term_code -> list of completed course codes
            planned_courses: Dict mapping term_code -> list of planned course codes
            max_courses_per_term: Maximum courses allowed per term (default: 3)
            
        Returns:
            Validation result with success status, issues, and recommendations
        """
        course = self.course_loader.get_course(course_code)
        if not course:
            return {
                'valid': False,
                'issues': [f"Course {course_code} not found"],
                'recommendations': []
            }
        
        # Parse requirements
        requirements = self.prereq_parser.parse_requirements(course.requirements_description)
        
        # Get all courses completed before target term
        prior_courses = self._get_courses_before_term(target_term, completed_courses, planned_courses)
        
        validation_result = {
            'valid': True,
            'issues': [],
            'warnings': [],
            'recommendations': [],
            'prerequisite_status': {},
            'antirequisite_conflicts': [],
            'requirements_summary': requirements
        }
        
        # Check if course is offered in target term
        offering_status = self.course_loader.get_offering_status_for_term(course_code, target_term)
        if not offering_status["is_offered"]:
            validation_result['valid'] = False
            validation_result['issues'].append(f"Course {course_code} is not offered in term {target_term} ({offering_status['status']})")
        elif offering_status["status"] != "Confirmed":
            # Add warning for predicted offerings
            validation_result['warnings'].append(f"Course offering in term {target_term} is {offering_status['status']}")
        
        # Check semester capacity
        capacity_check = self._check_semester_capacity(target_term, completed_courses, planned_courses, max_courses_per_term)
        if not capacity_check['valid']:
            validation_result['valid'] = False
            validation_result['issues'].extend(capacity_check['issues'])
        if capacity_check.get('warnings'):
            validation_result['warnings'].extend(capacity_check['warnings'])
        
        # Check if this is a 500-level course (graduate exemption)
        course_level = self._get_course_level(course_code)
        is_500_level = course_level == 5
        
        # Check prerequisites (with graduate exemption for 500-level courses)
        prereq_issues = self._check_prerequisites(requirements['prerequisites'], prior_courses, is_500_level)
        validation_result['prerequisite_status'] = prereq_issues
        
        if any(not status['satisfied'] for status in prereq_issues.values()):
            if is_500_level:
                # For 500-level courses, convert failed prerequisites to warnings
                validation_result['warnings'].extend([
                    f"Note: Prerequisite recommended but not required for graduate students: {status['requirement']}" 
                    for req, status in prereq_issues.items() 
                    if not status['satisfied']
                ])
            else:
                validation_result['valid'] = False
                validation_result['issues'].extend([
                    f"Prerequisite not satisfied: {status['requirement']}" 
                    for req, status in prereq_issues.items() 
                    if not status['satisfied']
                ])
        
        # Check antirequisites
        antireq_conflicts = self._check_antirequisites(course_code,
                                                      requirements['antirequisites'], 
                                                      prior_courses, 
                                                      completed_courses, 
                                                      planned_courses)
        validation_result['antirequisite_conflicts'] = antireq_conflicts
        
        if antireq_conflicts:
            validation_result['valid'] = False
            validation_result['issues'].extend([
                f"Antirequisite conflict: Cannot take {course_code} if {conflict} is completed/planned"
                for conflict in antireq_conflicts
            ])
        
        # Check level requirements
        level_issues = self._check_level_requirements(requirements['level_requirements'], target_term)
        if level_issues:
            validation_result['warnings'].extend(level_issues)
        
        # Check for dependent courses that would be invalidated by this move
        dependent_course_issues = self._check_dependent_courses(course_code, target_term, completed_courses, planned_courses)
        if dependent_course_issues:
            validation_result['valid'] = False
            validation_result['issues'].extend(dependent_course_issues)
        
        return validation_result
    
    def _get_courses_before_term(self, 
                               target_term: str, 
                               completed_courses: Dict[str, List[str]],
                               planned_courses: Dict[str, List[str]] = None) -> List[str]:
        """Get all courses completed before the target term."""
        if planned_courses is None:
            planned_courses = {}
            
        all_prior_courses = []
        target_term_int = int(target_term)
        
        # Add completed courses from earlier terms
        for term_code, courses in completed_courses.items():
            if int(term_code) < target_term_int:
                all_prior_courses.extend(courses)
        
        # Add planned courses from earlier terms
        for term_code, courses in planned_courses.items():
            if int(term_code) < target_term_int:
                all_prior_courses.extend(courses)
        
        return all_prior_courses

    def _check_semester_capacity(self, target_term: str, completed_courses: Dict[str, List[str]], 
                                planned_courses: Dict[str, List[str]] = None, max_courses: int = 3) -> Dict[str, Any]:
        """Check if the target term has capacity for another course."""
        if planned_courses is None:
            planned_courses = {}
        
        # Count courses already in the target term
        current_courses_in_term = 0
        
        # Count completed courses in target term
        if target_term in completed_courses:
            current_courses_in_term += len(completed_courses[target_term])
        
        # Count planned courses in target term  
        if target_term in planned_courses:
            current_courses_in_term += len(planned_courses[target_term])
        
        # Hard limit at 3 courses - absolutely cannot exceed
        if current_courses_in_term >= max_courses:
            return {
                'valid': False,
                'issues': [f"Maximum {max_courses} courses per semester. Current term already has {current_courses_in_term} courses."],
                'warnings': []
            }
        
        # Warning when approaching limit (2 courses)
        warnings = []
        if current_courses_in_term == 2:
            warnings.append(f"You have {current_courses_in_term} courses. Maximum is {max_courses} per semester.")
        
        return {
            'valid': True,
            'issues': [],
            'warnings': warnings
        }
    
    def _check_prerequisites(self, prerequisites: List[Dict], prior_courses: List[str], is_graduate_exempt: bool = False) -> Dict[str, Dict]:
        """Check if prerequisites are satisfied."""
        status = {}
        
        for i, prereq in enumerate(prerequisites):
            # Use the actual requirement description as the key instead of generic req_id
            req_description = prereq.get('description', f"Requirement {i+1}")
            
            if prereq['type'] == 'required':
                # All courses must be completed
                required_course = prereq['courses'][0]['full_code']
                satisfied = required_course in prior_courses
                status[req_description] = {
                    'requirement': req_description,
                    'satisfied': satisfied,
                    'type': 'required',
                    'missing_courses': [] if satisfied else [required_course]
                }
                
            elif prereq['type'] == 'one_of':
                # At least one course must be completed
                satisfied = any(course['full_code'] in prior_courses for course in prereq['courses'])
                missing_courses = [course['full_code'] for course in prereq['courses']]
                status[req_description] = {
                    'requirement': req_description,
                    'satisfied': satisfied,
                    'type': 'one_of',
                    'missing_courses': missing_courses if not satisfied else []
                }
        
        return status
    
    def _check_antirequisites(self, 
                            course_code: str,
                            antirequisites: List[str], 
                            prior_courses: List[str],
                            completed_courses: Dict[str, List[str]],
                            planned_courses: Dict[str, List[str]] = None) -> List[str]:
        """Check for antirequisite conflicts (bidirectional)."""
        conflicts = []
        
        if planned_courses is None:
            planned_courses = {}
        
        # Combine all completed and planned courses
        all_courses = prior_courses.copy()
        for courses in completed_courses.values():
            all_courses.extend(courses)
        for courses in planned_courses.values():
            all_courses.extend(courses)
        
        # Check direct antirequisites (A lists B as antirequisite)
        for antireq in antirequisites:
            if antireq in all_courses:
                conflicts.append(f"{antireq} (listed as antirequisite of {course_code})")
        
        # Check reverse antirequisites (B lists A as antirequisite)
        for existing_course in all_courses:
            if existing_course == course_code:
                continue
                
            existing_course_data = self.course_loader.get_course(existing_course)
            if existing_course_data:
                existing_requirements = self.prereq_parser.parse_requirements(existing_course_data.requirements_description)
                existing_antireqs = existing_requirements.get('antirequisites', [])
                
                if course_code in existing_antireqs:
                    conflicts.append(f"{existing_course} (lists {course_code} as antirequisite)")
        
        return conflicts
    
    def _check_level_requirements(self, level_requirements: List[Dict], target_term: str) -> List[str]:
        """Check level requirements (simplified - would need student level info)."""
        warnings = []
        
        # This is a simplified check - in a real system, you'd need to track student academic level
        for req in level_requirements:
            warnings.append(f"Verify you meet level requirement: {req['minimum_level']} in {req['program']}")
        
        return warnings

    def _check_dependent_courses(self, course_code: str, target_term: str, completed_courses: Dict[str, List[str]], planned_courses: Dict[str, List[str]]) -> List[str]:
        """
        Check if any courses that depend on the target course are already placed in earlier terms.
        This prevents moving prerequisite courses after their dependent courses are already scheduled.
        """
        def get_term_name(term_code: str) -> str:
            """Convert term code to readable name."""
            if len(term_code) != 4:
                return term_code
            
            year = "20" + term_code[1:3]
            month = term_code[3]
            
            season_map = {
                "1": "Winter",
                "5": "Spring", 
                "9": "Fall"
            }
            
            season = season_map.get(month, "Unknown")
            return f"{season} {year}"
        
        issues = []
        target_term_int = int(target_term)

        # Combine both completed and planned courses for comprehensive checking
        all_courses = {}
        for term_code, courses in completed_courses.items():
            all_courses[term_code] = all_courses.get(term_code, []) + courses
        if planned_courses:
            for term_code, courses in planned_courses.items():
                all_courses[term_code] = all_courses.get(term_code, []) + courses

        # Check antirequisites (if the target course is an antirequisite of any other)
        for existing_course in all_courses.get(target_term, []):
            if existing_course != course_code:  # Don't check against itself
                existing_course_data = self.course_loader.get_course(existing_course)
                if existing_course_data:
                    existing_requirements = self.prereq_parser.parse_requirements(existing_course_data.requirements_description)
                    existing_antireqs = existing_requirements.get('antirequisites', [])
                    if course_code in existing_antireqs:
                        issues.append(f"Cannot move {course_code} to term {target_term} because {existing_course} (listed as antirequisite) is already in this term.")

        # Check if any courses in earlier terms depend on this course as a prerequisite
        # This prevents moving prerequisite courses after their dependent courses
        for term_code, courses in all_courses.items():
            try:
                term_int = int(term_code)
                if term_int < target_term_int:  # Check EARLIER terms, not later ones!
                    for dependent_course in courses:
                        if dependent_course != course_code:  # Don't check against itself
                            dependent_course_data = self.course_loader.get_course(dependent_course)
                            if dependent_course_data:
                                dependent_requirements = self.prereq_parser.parse_requirements(dependent_course_data.requirements_description)
                                # Check if the target course is a prerequisite for the dependent course
                                for prereq_group in dependent_requirements.get('prerequisites', []):
                                    if isinstance(prereq_group, dict):
                                        prereq_courses = prereq_group.get('courses', [])
                                        # Check if any prerequisite course matches the target course
                                        for prereq_course in prereq_courses:
                                            if isinstance(prereq_course, dict):
                                                # Handle structured prerequisite (dict with full_code, subject, number)
                                                if prereq_course.get('full_code') == course_code:
                                                    target_term_name = get_term_name(target_term)
                                                    dependent_term_name = get_term_name(term_code)
                                                    issues.append(f"Cannot move {course_code} to {target_term_name} because {dependent_course} (which requires it as prerequisite) is already scheduled in {dependent_term_name}")
                                            elif isinstance(prereq_course, str) and prereq_course == course_code:
                                                # Handle simple string prerequisite
                                                target_term_name = get_term_name(target_term)
                                                dependent_term_name = get_term_name(term_code)
                                                issues.append(f"Cannot move {course_code} to {target_term_name} because {dependent_course} (which requires it as prerequisite) is already scheduled in {dependent_term_name}")
                                    elif isinstance(prereq_group, str) and course_code in prereq_group:
                                        target_term_name = get_term_name(target_term)
                                        dependent_term_name = get_term_name(term_code)
                                        issues.append(f"Cannot move {course_code} to {target_term_name} because {dependent_course} (which requires it as prerequisite) is already scheduled in {dependent_term_name}")
            except (ValueError, TypeError):
                # Skip invalid term codes
                continue

        return issues

class TermSequenceManager:
    """Manages term sequences and course scheduling."""
    
    def __init__(self):
        self.term_order = self._generate_term_order()
    
    def _generate_term_order(self) -> List[str]:
        """Generate chronological order of terms."""
        terms = []
        
        # Generate terms from 2020 to 2030
        for year in range(2020, 2031):
            year_str = str(year)[2:]  # Last 2 digits
            terms.extend([
                f"1{year_str}1",  # Winter (January)
                f"1{year_str}5",  # Spring (May) 
                f"1{year_str}9"   # Fall (September)
            ])
        
        return sorted(terms)
    
    def get_terms_before(self, target_term: str) -> List[str]:
        """Get all terms that occur before the target term."""
        if target_term not in self.term_order:
            return []
        
        target_index = self.term_order.index(target_term)
        return self.term_order[:target_index]
    
    def get_terms_after(self, target_term: str) -> List[str]:
        """Get all terms that occur after the target term."""
        if target_term not in self.term_order:
            return []
        
        target_index = self.term_order.index(target_term)
        return self.term_order[target_index + 1:]
    
    def is_term_before(self, term1: str, term2: str) -> bool:
        """Check if term1 occurs before term2."""
        try:
            return self.term_order.index(term1) < self.term_order.index(term2)
        except ValueError:
            return False
    
    def get_term_name(self, term_code: str) -> str:
        """Convert term code to readable name."""
        if len(term_code) != 4:
            return term_code
        
        year = "20" + term_code[1:3]
        month = term_code[3]
        
        season_map = {
            "1": "Winter",
            "5": "Spring", 
            "9": "Fall"
        }
        
        season = season_map.get(month, "Unknown")
        return f"{season} {year}"

 